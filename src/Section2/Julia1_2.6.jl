# julia1_2.6.jl String Operations and Pattern matching
#
# String character addressing 1 to end
# The first byte of a UTF-8 multibyte character
# will yield the character, the other bytes cause exceptions
s="Abcπ∑z\u2200\n" # or s=string("Abcπ∑z∀")
# ∀ for each operator (eg. ∀x∊S for each x belonging to set S)

println(sizeof(s)) # total number of bytes in string
println(length(s)) # length in characters
# best way to deal with each character
for c in s
    print(c)
end

# and this can become a one liner using ";"
for c in s; print(c); end

println(s[5]) # this will cause an exception since continuation byte

name="Mike"
n=76
s=string("Hi ",name,n,30,"  ",π,",\n") # Converts and concatenates

# julia uses * for concatenation
#  rather than + (+ implies communtative)
s="Hi "*name*",/n"

s="hi $name,\n"   # so using String is not necessary
# The $ operator can also be used to evaluate expressions
n=63
s="Hi $(sqrt(n+1)),\n"

# triple quote used for embedded quotes and indentation
lem="""
         The lead lemming said, "Jump!"
         and they all did.
    """
println(lem)

for i=0x2200:0x2240; print(Char(i)); end # interesting symbols

###

t='a'*'z'
u='z'-'a'
v='a'+1
w='a'+'b' # meaningless so error

# character comparisons
'A'<='X'<='Z'   # true comparison
'A'<='a'<='Z'   #false comparison

# lexicographic ordering using < > <= >= == !=
"abacus"<"zoo"   # true
"Zoo"<"abacus"   # true because 'Z'<'a'Char'
"Zoo"<"Abacus"   # false
"α"<"𝛂"          # true because first alpha from lower greek alphabet.

s="πAbc∑z\u2200\n"
t=chomp(s)
chop(t)
lowercase(t)
uppercase(t)
t[end]
first(t)  # all strings start at 1.
Last(t)
split(t,'∑')
strip("   "*t*"   ")
textwidth(s)
i=1   # all strings start at 1.
t[i]
i=nextind(t,i)
t[i]
textwidth(s)


###

# regular expressions (type Regex)- Perl compatible
# see www.pcre.org
# Regex common escape sequences - table
# \a   An alarm bell
# \c?  The control character you specify for ?
# \d   A digit between 0 and 9
# \D   A non digit character
# \e   The character generated by pressing escape
# \E   The end of an \L or \U sequence
# \f   A form feed
# \l   The next lower case character
# \L   The next lower case characters until \E
# \n   A new line of data
# \Q   The next metacharacter until \E is found
# \r   a carriage return
# \s   A whitespace character
# \S   A non-white space character
# \t   A tab
# \u   The next Uppercase character
# \U   The next uppercase characters until \E
# \w   A word character (alphanumeric characters or underscores)
# \W   A non-word characters
# \O?  The octal character you specify for ?
# \x?  The hexadecimal character you specify for ?

Other metacharacters
# ^    Match at beginning of String
# $    Match at end of String
# +    1 or more of preceding type
# *    0 or more of preceding type
# [?-?]  match range, eg. [A-G], [1-5] and [A-Za-z]

# Test to make sure password not all alpha
i=0
while(i==0)
    global i
    passwd=readline()
    if match(r"^[A-Za-zα-ω]*$",passwd) === nothing
        println("password good")
        i=1
    else
        println("all alpha, try again")
    end
end

# pick time out of text
linewithtime="a good holiday weekend, its 15:45 and sunny."
m=match(r"(?<hour>\d+):(?<minute>\d+)",linewithtime)
println(m[:hour]*":"*m[:minute])

# For more read Redex Cheat Sheet at:
#   www.rexegg.com/regex-quickstart.html
