# julia1_2.6.jl String Operations and Pattern matching
#
# String character addressing 1 to end
# The first byte of a UTF-8 multibyte character
# will yield the character, the other bytes cause exceptions
s="Abcπ∑z\u2200" # or s=string("Abcπ∑z∀")
# ∀ 'for each operator (eg. ∀x∈S for each x belonging to S)

println(sizeof(s)) # total number of bytes in string

println(s[5]) # this will cause an exception since continuation byte

# This works but relies on print errors:
for i = 1:sizeof(s) # or 1:endof(S)
    try print(s[i])
    catch  # ignore continuation byte error
    end
end
# To avoid print having to catch errors
i=1
while i<=endof(s)  # rng=1 to byte addr of last char
    print(s[i])
    i=nextind(s,i)  # yields next character
end
# but better to do this instead:
for c in s
    print(c)
end
# and this can become a one liner using ";"
for c in s; print(c); end

# string concatenation - 3 ways
name="Mike"
s=string("Hi ",name,",\n") # Converts and concatenates
# julia uses * for concatenation
#  rather than + (+ implies communtative)
s="Hi "*name*",\n"

s="Hi $name,\n"  # String() not necessary

# The $ operator can also be used to evaluate expressions
s="Hi $(sqrt(π+1)),\n"

search(s,'9') # find an 8 in the π+1 String

t='a'*'z'
u='z'-'a'
v='a'+1
w='a'+'b' # meaningless so error

# character comparisons
'A'<='X'<='Z'   # true comparison
'A'<='a'<='Z'   #false comparison

# regular expressions (type Regex)- Perl compatible
# see www.pcre.org
# Regex common escape sequences - table
# \a   An alarm bell
# \c?  The control character you specify for ?
# \d   A digit between 0 and 9
# \D   A non digit character
# \e   The character generated by pressing escape
# \E   The end of an \L or \U sequence
# \f   A form feed
# \l   The next lower case character
# \L   The next lower case characters until \E
# \n   A new line of data
# \Q   The next metacharacter until \E is found
# \r   a carriage return
# \s   A whitespace character
# \S   A non-white space character
# \t   A tab
# \u   The next Uppercase character
# \U   The next uppercase characters until \E
# \w   A word character (alphanumeric characters or underscores)
# \W   A non-word characters
# \O?  The octal character you specify for ?
# \x?  The hexadecimal character you specify for ?

Other metacharacters
# ^    Match at beginning of String
# $    Match at end of String
# +    1 or more of preceding type
# *    0 or more of preceding type
# [?-?]  match range, eg. [A-G], [1-5] and [A-Za-z]

# Test to make sure password not all alpha
i=0
while(i==0)
    passwd=readline()
    if ismatch(r"^[A-Za-zα-ω]*$",passwd)
        println("all alpha, try again")
    else
        println("password good")
        i=1
    end
end

# pick time out of text
linewithtime="a good holiday weekend, its 15:45 and sunny."
m=match(r"(?<hour>\d+):(?<minute>\d+)",linewithtime)
println(m[:hour]*":"m[:minute])

# For more read Redex Cheat Sheet at:
#   www.rexegg.com/regex-quickstart.html
